Magic funkcije u pajtonu

%run "../nekinotebook.ipynb" - sve se urazi iz ove skripte


Jupyter notebook se koristi za ovo
------------------
Pandas - služi za analizu podataka

axis 0 redovi
axis 1 kolone

svakom redu i svakoj koloni se pristupa kao celini

----------
import matplotlib.pyglo as plt   -za crtanje
plt.style.use('classic') - neki klasicni stil crtanja


import seaborn as sb --isto za crtanje, nadogradnja na matplotlib

--------------------
Dataset - neki skup podataka
-----------------------
from pandas as pd

Ucitavanje dataseta


songs = pd.read_csv("putanja do csv fajla")  -- songs ce da dobije objekat pd.DataFrame

ako imamo neku kolonu koja je datum mozemo eksplicitno damu kazemo da tu kolonu tretira kao datum tako sto iza putanje fajla dodamo parse_dates=['kolona_datuma']


i sada kada ukucamo

songs

prikazacee nam se podaci u tabeli
------------------------------------


songs.shape  - vraca broj kolona i vrsta (vrste, kolone)

songs.head(10) - vraca prvih 10 podataka

songs.tail(10) - vraca poslednjih 10 podataka

songs.sample(10) - vraca 10 random podataka

song.dtypes - vraca koje sve tipove podataka imamo u datasetu tj kolone kog su tipa


songs.info() - vraca za svaku kolonu koliko ima podataka koji su non-null i vraca tip podataka

songs.describe() - vraca podatke iz deskriptivne statistike za svaku numericku kolonu ono (count, mean, std, min, 25%, 50%, 75%, max)


songs.columns - vraca sve nazive kolona ali u tipu podatka Index

Da pretvorimo to u listu:
1)list(songs.columns)
2)songs.columns.tolist()


songs.columns.valuess - dobijamo niz naziva kolona


songs.values - dobijemo niz kolona, gde je svaka kolona zapravo niz odgovarajucih vrednosti
znaci bukv dobijemo tabelu samo nam ne pisu nazivi kolona
--------------------------------
Zamena imena kolona

{sta menjamo: sa cime}
songs.rename({'track_name':'track, 'album_name':'album'}, axis='columns', inplace=True)

inplace=True - da zameni za stalno
----------------------------
Zamena redosleda kolona

list(songs.columns).index('neka_kolone') --ako zelimo da vidimo indeks kolone -npr ta kolona je 6

columns = ['track', 'artists', 'album, 'album_type', 'duration', 'release_year']

columns.extend(list(songs.columns)[6:])

songs = songs.reindex(columns=columns)
------------------------------
Cuvanje izmenjenog dataseta - ovo cesto raditi kako bismo se lakse vratili


songs.to_csv('../data/imefajla_csv', index=False) 

index=False -  dodace i kolonu indexa na pocetku sto nije potrebno


i onda posle ucitamo taj dataset

songs = pd.read_csv('../data/imefajla_csv')
-------------------------------
Provera nedostajućih vrednosti

songs.isna() - vraca DataFrame gde je True gde je False (prikaz je kao tabela gde su True ili False vrednosti), a ako imamo samo jednu kolonu onda vraca Series


ako zelimo da to prikazemo u nekoj heatmapi to mozemo iz seaborna

sb.heatmap(songs.isna)=, cbar=False, cmap='viridis')       

cmap - kolormape koje ce da koristi
cbar - da li da prikaze color bar sa strane
(da nam se ne bi prikazivalo Axes, stavimo ; na kraju npr ovde sb.heatmap();)

Sumiranje


songs.isna().sum() -sumira po kolonama koliko ima praznih


isto mozemo samo neke kolone da izdvojimo

songs.isna(['kolona1', 'kolona2']).sum()


---------------------------------
Prebrojavanje u koliko kolona ima koliko nedostajucih vrednosti, znaci grupise po vrednosti

songs.isna().sum().value_counts()
-----------------------------------------
Prikazivanje koliko ima kolona gde ima nesto sto nedostaje

i = songs.isna().sum() > 0
i[i] - da indeksira samo gde je indeks true OVO ZAPAMTI BITNO JE AS


-------------------
songs.loc[:, i] - vraca kolone gde nema nedostojucih vrednosti, znaci DataFrame vraca

loc -[:] adresija celu tabelu

[:, i] - samo po indeksima i
-----------------------------
Izostavljanje svih vrednosti gde ima praznih vrednosti negde

songs.dropna()



songs['producers'].dropna() - samo za neku kolonu

-------------------------------
izostavljanje kolona koje imaju prazne vrednosti

songs.dropna(axis=1)
---------------------------
songs.value_counts() - dodaje kolonu u DateFrame, grupise vrednosti i prikazuje koliko ima pojavljivanja za svaku vrednost
songs.value_counts(normalize = True) - samo prikazuje u procentima od ukupnog dataset-a


moze i za samo neku kolonun

songs.album_type.value_counts()
-------------------------------------------
Duplikati


songs.duplicated() - ovo ce da vrati koji redovi su duplirani

song.duplicated('tracked') -ovo ce da vrati koji redovi su duplirani po ovoj koloni



songs.drop_duplicates('track') -ovo ce da obrise sve duplirane redove po koloni track, vraca DataFrame


songs = songs.loc[songs.album_type.isin(['studio album', 'single', 'extended play'])] - ovo ce da vrati sve podatke gde kolona album_type ima ove vrednosti



------OBRATI PAZNJU

iako smo obrisali sve duplikate u track moze da se se desi da se nesto ne obrise i onda mozemo da proverimo sa

song.track.duplicated().sum()

i onda kao imamo nesto da se ponavlja to mozemo da nadjemo 

songs.loc[songs.track.duplicated()] -vratice se ono gde je true i onda na osnovu track mozemo da vidimo od koga je dupliran

songs.loc[songs.track == 'Beter Man']

i onda ako hocemo da sacuvamo poslednji

songs.drop_druplicates('track', keep='last', inplace = True)

i onda kako bismo resetovali indekse da idu redom

songs.reset_index(drop=True, inplace = True)




---------------------------
Indeksi

kako bismo dobili indekse

songs.index

songs.index.tolist()


----------------------------------
Loc

loc je kao SELECT FROM u SQL-u

SELECT ... FROM songs
songs.loc[USLOV]
-----------------------------
Ako hoćemo da dobijemo gde ima duplikata

i = songs.isna().sum() > 0

i[i].index - dobijes indeks gde je true

i[i].values -> niz True-ova


i sada kad imamo indekse
mozemo da dobijemo DataFrame gde imamo kololne gde imamo neke nedosttajuce kolone

songs.loc[:,i]


koliko ima kolona gde ima nedostajucih vrednosti


songs.isna().sum()[i]

----------------------------------------
Kako sad da prodjemo redove gde ima praznih stvari

: -sve kolone ili redovi

songs.loc[songs.isna().any(axis=1),:]
-------------------------------
kako da dobijemo podatke gde peva npr neki pevac

songs.loc[songs.artists == 'Alice in Chains']

-----------------------------------------
AKO IMAMOO VISE VREDNOSTI

songs.loc[(songs.artists == 'Alice in Chains') & (songs.album_type == 'studio)] --ZNACI OVDE NE IDE and

---------------------
iloc - niz nekih numerickih indeksa


nesto.iloc[:n, :m]  -selektuje prvih n redova, i m kolona

nesto.iloc[-5:, [0,1,4]] -poslednjih 5 i ove 3 kolone

OBJASNI STA ZNACI :

i = song.tracks_composers.isna()

i[i] = da dobijemo samo one koji su true

i_iloc = i[i].index



songs.iloc[i_loc, [0,1,2]] ali ovde gde su kolone MORAMO da pisemo indekse tih kolona

ekvivalentno je

songs.loc[i_iloc, ['track','composers','track_composers']] 


ako hocemo da onda pomocu toga da zamenimo nedostajuce vrednostii


songs.loc[i_iloc, ['track_composers']] = 'unknown'  

ovo ce da zameni sve podatke u track_compoers gde je Nan sa unknown

i onda ce

song.tracks_composers.isna() da vrati nulu
-------------------------------------------
isin - da je u nekom opsegu


early_years = [y = y in range(1989, 1995)]

songs.loc[songs.release_year.isin(early_years), ['track', 'artists', 'release_year']]

KORISNO:
ako hocemo da proverimo da li negde nesto pocinje sa nekim stringom

songs.track.startswith('string')

ali track npr nije string samo dodamo .str

songs.track.str.startswith('string')



#############################
GROUPBY


Unique


songs.release_year.unique()

songs.release_Year.nunique() - da prebroji koliko ima neunikatnih




GroupBy


songs_by_year = sogns.groupby('release_year')   --ovo vraca grupisani DataFrameGroupBy


i sada mozemo da dobijemo vrednosti za odredjenu godinu npr


songs_by_tea.get_group(1989) - ovo ce da nam vrati DataFrame gde su samo godine ciji je release_Year 1989



ako npr hocemo da dobijemo za svaku godinu koliko im count


songs.release_year.value_counts()

-----------------------------------
Sortiranje Seriesa

songs.release_year.value_counts().sort_index(ascending = False) -- ovo je po indeksu(prva kolona)


songs.release_year.value_counts().sort_values(ascending = False) -- ovo je po vrednosti(druga kolona)
-------------------------
Sortiranje DataFramea

songs.sort_values('release_year) - po koloni release year

------------------------------

Grupisanje po nekoj koloni ali sa uzlovom iz druge kolone (VALJDA OBJASNI MALO BOLJE)

songs.groupby('release_year').duration.mean().sort_values(ascending=False)


Agregarcija

Mramo da kaezmo po cemu sortiramo

songs.groupby('release_year').duration.agg(['count', 'mean', 'max']).sort_values(by='count', ascending=False)  
----------------------
Za pretvaranje podataka u numericki oblik

try:
	lista['kolona'] = pd.to_numeric(lista['kolona'], errors="coerce)
except ValueError as err:
	print(err)
coerce - da postavi na NaN sta ne moze da transformise
----------------------------
-----------------------
ako prolazimo kroz direktorijum sa csv fajlovima


def get_csv_files(fpath: Path) -> list:
	if not fpath.is_dir():
		raise RuntimeError("The input argument is not a directory -> cannot proceed")
	csv_files = []
	for item in fpath.iterdir():
		if not item.is_dir() and item.suffix == '.csv':
			csv_files.append(item)
	return csv_files
-------------------------
Kada spajamo vise csv fajlova u dataframe

tako sto dodajemo nove redove

all_sales = pd.DataFrame()
for csv_file in get_csv_files(DATA_DIR):
	temp_df = pd.read_csv(csv_file)
	all_sales = pd.concat([all_sales, temp_dif]


i onda moramo da popravimo indekse

all_sales.reset_index(drop=True, inplace=True)



-------------------------
BITNOO, OVAKO NE NEKREIRAMO NOVI DATAFRAME

sales = all_sales

(proveri sa id(sales) = id(all_sales) ili sa sales is all_sales)
VEC OVAKO

sales = all_sales.copy()
------------------------
Dropna
OVDE OBJASNI STA JE KOD HOW all a sta je any

i sta je subset

sales.dropna(how="any", inplace=True, subset=["Price_Each","Quantity_Ordered"]

----------------------------


Pretvaranje u date time

sales['Order_Date'] = pd.to_datetime(sales['Order Date', errors='coerce',format='%m/%d/%y %H:%M']
-------------------
Izbacivanje kolona ili redova


sales.drop(columns=['kolona1', 'kolona2', 'kolona3'], inplace=True)
--------------------------------
Primeniti neke promene na elemente kolone sa apply

sales['nova_kolona'] = sales['kolona'].apply(funkcija)


-----------------------
kreiranje direktorijuma

processed_data = DIR / 'processed_data'

processed_data_dir.mkdir(parents=True, exist_ok=True)

OBJASNI parents i exist_ok
----------------------



Pristup kolonama

ako kolona nema space izmedju reci mozemo pristupiti sa npr

sales.Price_Each 

dok ako ima moramo ovako

sales['Price_Each']



Dodavanje nove kolone, kada dodajemo novu kolonu moramo ovako sales['Total_Revenue'] a ne ovako sales.Total_Revenue  pa onda uradimo nešto ovako npr


sales['Price_Each'] = sales.Quantity_Ordered * sales.Price_Each


----------------
Pristup pojedinacnim vrednostima datetimeu

pomocu .dt.month ili bilo sta drugo

sales.Order_Date.dt.month
-----------------------
Grupisanje po vise kolona

sales_per_city_products = sales.groupby(['Product','Purchase_City'].Total_Revenue.sum()

Ovo ce vratiti Series sa  dva indexa

Ako ovo treba da pretvorimo u DataFrame to radimo sa unstack()


sales_per_city_product.unstack() gde ce index biti prva kolona
------------------------------
Heatmape pomocu Matplotliba


products = df.index.tolist()
cities = df.columns.tolist()

_, ax = plt.subplots(figsize=(6, 9))


hm = ax.imshow(df, cmap='PuRd_r') - OVAKO SE KREIRA

MORAMO POSTAVITI RANGE I LABELE

ax.set_xticks(range(len(cities)), labels=cities)
ax.set_yticks(range(len(products)), labels=products)

BILO BI LEPO DA ROTIRAMO LABELE KOJE SU NA HORIZONTALNOJ OSI

ax.tick_params(axis='x', labelrotation=90, labelsize=9)
ax.tick_params(axis='y', labelsize=9)


PRIKAZIVANJE COLORBARA, MORAMO DA PREBACIMO OVAJ NAS HEATMAP I AXES

cbar = ax.figure.colorbar(hm, ax=ax)
cbar.ax.set_ylabel("Total revenue in USD", rotation=-90, va="bottom")

plt.show()

-------------------------
Kada pretvaramo series u dataframe to radimo sa to_frame()

sales_per_city_df = sales_per_city.to_frame()

i trebali bismo da resetujemo indexe

sales_per_city_df.reset_index(inplace=True)

-------------------------------
Treemap plot

_, ax = plt.subplots()

squarify.plot(
	sizes=sales_per_city_df.Quantity_Ordered,
	label=sales_per_city_df.City,
	ax=ax
)
plt.show()


Faktorizacija
OVO OBJASNI


state_num_labels, unique_states = pd.factorize(sales_per_city_df.State)

cmap = pypalettes.load_cmap("Abbott")
colors=[cmap(i) for i in state_num_labels]

i onda sad

_, ax = plt.subplots()
ax.set_axis_off()  -

squarify.plot(
	sizes=sales_per_city_df.Quantity_Ordered,
	label=sales_per_city_df.City,
	color=colors
	text_kwargs={'color':'white'} -- OBJASNI
	pad=True -- OBJASNI
	ax=ax
)
plt.show()
---------------------------------------
Ako treba da prikazemo dve linije na istom grafikovnu to radimo sa .twinx()


x = sales_per_product.index.tolist()
y1 = sales_per_product.Total_Revenue.tolist()
y2 = sales_per_product.Quantity_Ordered.tolist()

fig, ax1 = plt.subplots(figsize=(8,7))

col_QO = "teal"
col_OR = 'orchid'

ax1.plot(x, y1, color=col_OR, marker="d")
ax1.tick_params(axis='x', labelrotation=90, labelsize=9)
ax1.tick_params(axis='y', labelcolor=col_OR)
ax1.set_ylabel("Order revenue in million USD", color=col_OR)
ax1.grid(visible=True, axis='x', color='slategray', alpha=0.5)

ax2 = ax1.twinx()  -- OVA FUNKCIJA IZVLACI JOS JEDAN AXIS
ax2.plot(x, y2, color=col_QO, marker="^")
ax2.tick_params(axis='y', labelcolor=col_QO)
ax2.set_ylabel("Quantity ordered", color=col_QO)

fig.tight_layout()

plt.show()

